// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: src/protos/comment.proto
/* eslint-disable */

import type { ByteSource, PartialDeep } from "protoscript";
import * as protoscript from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

export interface GetCommentsResponseDto {
  comments: Comment[];
}

export interface DeleteCommentResponseDto {
  success: boolean;
}

export interface EmptyComment {}

export interface CommentId {
  id: number;
}

export interface UpdateCommentDto {
  id: number;
  authorId: number;
  message: string;
  attachment: string;
  postId: number;
  createdAt: protoscript.Timestamp;
  updatedAt: protoscript.Timestamp;
}

export interface CreateCommentDto {
  authorId: number;
  message: string;
  attachment: string;
  postId: number;
}

export interface Comment {
  id: number;
  authorId: number;
  message: string;
  attachment: string;
  postId: number;
  createdAt: protoscript.Timestamp;
  updatedAt: protoscript.Timestamp;
}

//========================================//
//      CommentProto Protobuf Client      //
//========================================//

export async function getComments(
  emptyComment: EmptyComment,
  config?: ClientConfiguration,
): Promise<GetCommentsResponseDto> {
  const response = await PBrequest(
    "/CommentProto/getComments",
    EmptyComment.encode(emptyComment),
    config,
  );
  return GetCommentsResponseDto.decode(response);
}

export async function getComment(
  commentId: CommentId,
  config?: ClientConfiguration,
): Promise<Comment> {
  const response = await PBrequest(
    "/CommentProto/getComment",
    CommentId.encode(commentId),
    config,
  );
  return Comment.decode(response);
}

export async function createComment(
  createCommentDto: CreateCommentDto,
  config?: ClientConfiguration,
): Promise<Comment> {
  const response = await PBrequest(
    "/CommentProto/createComment",
    CreateCommentDto.encode(createCommentDto),
    config,
  );
  return Comment.decode(response);
}

export async function updateComment(
  updateCommentDto: UpdateCommentDto,
  config?: ClientConfiguration,
): Promise<Comment> {
  const response = await PBrequest(
    "/CommentProto/updateComment",
    UpdateCommentDto.encode(updateCommentDto),
    config,
  );
  return Comment.decode(response);
}

export async function deleteComment(
  commentId: CommentId,
  config?: ClientConfiguration,
): Promise<DeleteCommentResponseDto> {
  const response = await PBrequest(
    "/CommentProto/deleteComment",
    CommentId.encode(commentId),
    config,
  );
  return DeleteCommentResponseDto.decode(response);
}

//========================================//
//        CommentProto JSON Client        //
//========================================//

export async function getCommentsJSON(
  emptyComment: EmptyComment,
  config?: ClientConfiguration,
): Promise<GetCommentsResponseDto> {
  const response = await JSONrequest(
    "/CommentProto/getComments",
    EmptyCommentJSON.encode(emptyComment),
    config,
  );
  return GetCommentsResponseDtoJSON.decode(response);
}

export async function getCommentJSON(
  commentId: CommentId,
  config?: ClientConfiguration,
): Promise<Comment> {
  const response = await JSONrequest(
    "/CommentProto/getComment",
    CommentIdJSON.encode(commentId),
    config,
  );
  return CommentJSON.decode(response);
}

export async function createCommentJSON(
  createCommentDto: CreateCommentDto,
  config?: ClientConfiguration,
): Promise<Comment> {
  const response = await JSONrequest(
    "/CommentProto/createComment",
    CreateCommentDtoJSON.encode(createCommentDto),
    config,
  );
  return CommentJSON.decode(response);
}

export async function updateCommentJSON(
  updateCommentDto: UpdateCommentDto,
  config?: ClientConfiguration,
): Promise<Comment> {
  const response = await JSONrequest(
    "/CommentProto/updateComment",
    UpdateCommentDtoJSON.encode(updateCommentDto),
    config,
  );
  return CommentJSON.decode(response);
}

export async function deleteCommentJSON(
  commentId: CommentId,
  config?: ClientConfiguration,
): Promise<DeleteCommentResponseDto> {
  const response = await JSONrequest(
    "/CommentProto/deleteComment",
    CommentIdJSON.encode(commentId),
    config,
  );
  return DeleteCommentResponseDtoJSON.decode(response);
}

//========================================//
//              CommentProto              //
//========================================//

export interface CommentProto<Context = unknown> {
  getComments: (
    emptyComment: EmptyComment,
    context: Context,
  ) => Promise<GetCommentsResponseDto> | GetCommentsResponseDto;
  getComment: (
    commentId: CommentId,
    context: Context,
  ) => Promise<Comment> | Comment;
  createComment: (
    createCommentDto: CreateCommentDto,
    context: Context,
  ) => Promise<Comment> | Comment;
  updateComment: (
    updateCommentDto: UpdateCommentDto,
    context: Context,
  ) => Promise<Comment> | Comment;
  deleteComment: (
    commentId: CommentId,
    context: Context,
  ) => Promise<DeleteCommentResponseDto> | DeleteCommentResponseDto;
}

export function createCommentProto<Context>(service: CommentProto<Context>) {
  return {
    name: "CommentProto",
    methods: {
      getComments: {
        name: "getComments",
        handler: service.getComments,
        input: { protobuf: EmptyComment, json: EmptyCommentJSON },
        output: {
          protobuf: GetCommentsResponseDto,
          json: GetCommentsResponseDtoJSON,
        },
      },
      getComment: {
        name: "getComment",
        handler: service.getComment,
        input: { protobuf: CommentId, json: CommentIdJSON },
        output: { protobuf: Comment, json: CommentJSON },
      },
      createComment: {
        name: "createComment",
        handler: service.createComment,
        input: { protobuf: CreateCommentDto, json: CreateCommentDtoJSON },
        output: { protobuf: Comment, json: CommentJSON },
      },
      updateComment: {
        name: "updateComment",
        handler: service.updateComment,
        input: { protobuf: UpdateCommentDto, json: UpdateCommentDtoJSON },
        output: { protobuf: Comment, json: CommentJSON },
      },
      deleteComment: {
        name: "deleteComment",
        handler: service.deleteComment,
        input: { protobuf: CommentId, json: CommentIdJSON },
        output: {
          protobuf: DeleteCommentResponseDto,
          json: DeleteCommentResponseDtoJSON,
        },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const GetCommentsResponseDto = {
  /**
   * Serializes GetCommentsResponseDto to protobuf.
   */
  encode: function (msg: PartialDeep<GetCommentsResponseDto>): Uint8Array {
    return GetCommentsResponseDto._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes GetCommentsResponseDto from protobuf.
   */
  decode: function (bytes: ByteSource): GetCommentsResponseDto {
    return GetCommentsResponseDto._readMessage(
      GetCommentsResponseDto.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes GetCommentsResponseDto with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GetCommentsResponseDto>,
  ): GetCommentsResponseDto {
    return {
      comments: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetCommentsResponseDto>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.comments?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.comments as any,
        Comment._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetCommentsResponseDto,
    reader: protoscript.BinaryReader,
  ): GetCommentsResponseDto {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Comment.initialize();
          reader.readMessage(m, Comment._readMessage);
          msg.comments.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const DeleteCommentResponseDto = {
  /**
   * Serializes DeleteCommentResponseDto to protobuf.
   */
  encode: function (msg: PartialDeep<DeleteCommentResponseDto>): Uint8Array {
    return DeleteCommentResponseDto._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes DeleteCommentResponseDto from protobuf.
   */
  decode: function (bytes: ByteSource): DeleteCommentResponseDto {
    return DeleteCommentResponseDto._readMessage(
      DeleteCommentResponseDto.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes DeleteCommentResponseDto with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<DeleteCommentResponseDto>,
  ): DeleteCommentResponseDto {
    return {
      success: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DeleteCommentResponseDto>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.success) {
      writer.writeBool(1, msg.success);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: DeleteCommentResponseDto,
    reader: protoscript.BinaryReader,
  ): DeleteCommentResponseDto {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.success = reader.readBool();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const EmptyComment = {
  /**
   * Serializes EmptyComment to protobuf.
   */
  encode: function (_msg?: PartialDeep<EmptyComment>): Uint8Array {
    return new Uint8Array();
  },

  /**
   * Deserializes EmptyComment from protobuf.
   */
  decode: function (_bytes?: ByteSource): EmptyComment {
    return {};
  },

  /**
   * Initializes EmptyComment with all fields set to their default value.
   */
  initialize: function (msg?: Partial<EmptyComment>): EmptyComment {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<EmptyComment>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    _msg: EmptyComment,
    _reader: protoscript.BinaryReader,
  ): EmptyComment {
    return _msg;
  },
};

export const CommentId = {
  /**
   * Serializes CommentId to protobuf.
   */
  encode: function (msg: PartialDeep<CommentId>): Uint8Array {
    return CommentId._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CommentId from protobuf.
   */
  decode: function (bytes: ByteSource): CommentId {
    return CommentId._readMessage(
      CommentId.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CommentId with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CommentId>): CommentId {
    return {
      id: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CommentId>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CommentId,
    reader: protoscript.BinaryReader,
  ): CommentId {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const UpdateCommentDto = {
  /**
   * Serializes UpdateCommentDto to protobuf.
   */
  encode: function (msg: PartialDeep<UpdateCommentDto>): Uint8Array {
    return UpdateCommentDto._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes UpdateCommentDto from protobuf.
   */
  decode: function (bytes: ByteSource): UpdateCommentDto {
    return UpdateCommentDto._readMessage(
      UpdateCommentDto.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes UpdateCommentDto with all fields set to their default value.
   */
  initialize: function (msg?: Partial<UpdateCommentDto>): UpdateCommentDto {
    return {
      id: 0,
      authorId: 0,
      message: "",
      attachment: "",
      postId: 0,
      createdAt: protoscript.Timestamp.initialize(),
      updatedAt: protoscript.Timestamp.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<UpdateCommentDto>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.authorId) {
      writer.writeInt32(2, msg.authorId);
    }
    if (msg.message) {
      writer.writeString(3, msg.message);
    }
    if (msg.attachment) {
      writer.writeString(4, msg.attachment);
    }
    if (msg.postId) {
      writer.writeInt32(5, msg.postId);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        6,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.updatedAt) {
      writer.writeMessage(
        7,
        msg.updatedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: UpdateCommentDto,
    reader: protoscript.BinaryReader,
  ): UpdateCommentDto {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.authorId = reader.readInt32();
          break;
        }
        case 3: {
          msg.message = reader.readString();
          break;
        }
        case 4: {
          msg.attachment = reader.readString();
          break;
        }
        case 5: {
          msg.postId = reader.readInt32();
          break;
        }
        case 6: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 7: {
          reader.readMessage(msg.updatedAt, protoscript.Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const CreateCommentDto = {
  /**
   * Serializes CreateCommentDto to protobuf.
   */
  encode: function (msg: PartialDeep<CreateCommentDto>): Uint8Array {
    return CreateCommentDto._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes CreateCommentDto from protobuf.
   */
  decode: function (bytes: ByteSource): CreateCommentDto {
    return CreateCommentDto._readMessage(
      CreateCommentDto.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes CreateCommentDto with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CreateCommentDto>): CreateCommentDto {
    return {
      authorId: 0,
      message: "",
      attachment: "",
      postId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateCommentDto>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.authorId) {
      writer.writeInt32(2, msg.authorId);
    }
    if (msg.message) {
      writer.writeString(3, msg.message);
    }
    if (msg.attachment) {
      writer.writeString(4, msg.attachment);
    }
    if (msg.postId) {
      writer.writeInt32(5, msg.postId);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: CreateCommentDto,
    reader: protoscript.BinaryReader,
  ): CreateCommentDto {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 2: {
          msg.authorId = reader.readInt32();
          break;
        }
        case 3: {
          msg.message = reader.readString();
          break;
        }
        case 4: {
          msg.attachment = reader.readString();
          break;
        }
        case 5: {
          msg.postId = reader.readInt32();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Comment = {
  /**
   * Serializes Comment to protobuf.
   */
  encode: function (msg: PartialDeep<Comment>): Uint8Array {
    return Comment._writeMessage(
      msg,
      new protoscript.BinaryWriter(),
    ).getResultBuffer();
  },

  /**
   * Deserializes Comment from protobuf.
   */
  decode: function (bytes: ByteSource): Comment {
    return Comment._readMessage(
      Comment.initialize(),
      new protoscript.BinaryReader(bytes),
    );
  },

  /**
   * Initializes Comment with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Comment>): Comment {
    return {
      id: 0,
      authorId: 0,
      message: "",
      attachment: "",
      postId: 0,
      createdAt: protoscript.Timestamp.initialize(),
      updatedAt: protoscript.Timestamp.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<Comment>,
    writer: protoscript.BinaryWriter,
  ): protoscript.BinaryWriter {
    if (msg.id) {
      writer.writeInt32(1, msg.id);
    }
    if (msg.authorId) {
      writer.writeInt32(2, msg.authorId);
    }
    if (msg.message) {
      writer.writeString(3, msg.message);
    }
    if (msg.attachment) {
      writer.writeString(4, msg.attachment);
    }
    if (msg.postId) {
      writer.writeInt32(5, msg.postId);
    }
    if (msg.createdAt) {
      writer.writeMessage(
        6,
        msg.createdAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    if (msg.updatedAt) {
      writer.writeMessage(
        7,
        msg.updatedAt,
        protoscript.Timestamp._writeMessage,
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: Comment,
    reader: protoscript.BinaryReader,
  ): Comment {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.id = reader.readInt32();
          break;
        }
        case 2: {
          msg.authorId = reader.readInt32();
          break;
        }
        case 3: {
          msg.message = reader.readString();
          break;
        }
        case 4: {
          msg.attachment = reader.readString();
          break;
        }
        case 5: {
          msg.postId = reader.readInt32();
          break;
        }
        case 6: {
          reader.readMessage(msg.createdAt, protoscript.Timestamp._readMessage);
          break;
        }
        case 7: {
          reader.readMessage(msg.updatedAt, protoscript.Timestamp._readMessage);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const GetCommentsResponseDtoJSON = {
  /**
   * Serializes GetCommentsResponseDto to JSON.
   */
  encode: function (msg: PartialDeep<GetCommentsResponseDto>): string {
    return JSON.stringify(GetCommentsResponseDtoJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetCommentsResponseDto from JSON.
   */
  decode: function (json: string): GetCommentsResponseDto {
    return GetCommentsResponseDtoJSON._readMessage(
      GetCommentsResponseDtoJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes GetCommentsResponseDto with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<GetCommentsResponseDto>,
  ): GetCommentsResponseDto {
    return {
      comments: [],
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<GetCommentsResponseDto>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.comments?.length) {
      json["comments"] = msg.comments.map(CommentJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetCommentsResponseDto,
    json: any,
  ): GetCommentsResponseDto {
    const _comments_ = json["comments"];
    if (_comments_) {
      for (const item of _comments_) {
        const m = CommentJSON.initialize();
        CommentJSON._readMessage(m, item);
        msg.comments.push(m);
      }
    }
    return msg;
  },
};

export const DeleteCommentResponseDtoJSON = {
  /**
   * Serializes DeleteCommentResponseDto to JSON.
   */
  encode: function (msg: PartialDeep<DeleteCommentResponseDto>): string {
    return JSON.stringify(DeleteCommentResponseDtoJSON._writeMessage(msg));
  },

  /**
   * Deserializes DeleteCommentResponseDto from JSON.
   */
  decode: function (json: string): DeleteCommentResponseDto {
    return DeleteCommentResponseDtoJSON._readMessage(
      DeleteCommentResponseDtoJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes DeleteCommentResponseDto with all fields set to their default value.
   */
  initialize: function (
    msg?: Partial<DeleteCommentResponseDto>,
  ): DeleteCommentResponseDto {
    return {
      success: false,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<DeleteCommentResponseDto>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.success) {
      json["success"] = msg.success;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: DeleteCommentResponseDto,
    json: any,
  ): DeleteCommentResponseDto {
    const _success_ = json["success"];
    if (_success_) {
      msg.success = _success_;
    }
    return msg;
  },
};

export const EmptyCommentJSON = {
  /**
   * Serializes EmptyComment to JSON.
   */
  encode: function (_msg?: PartialDeep<EmptyComment>): string {
    return "{}";
  },

  /**
   * Deserializes EmptyComment from JSON.
   */
  decode: function (_json?: string): EmptyComment {
    return {};
  },

  /**
   * Initializes EmptyComment with all fields set to their default value.
   */
  initialize: function (msg?: Partial<EmptyComment>): EmptyComment {
    return {
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    _msg: PartialDeep<EmptyComment>,
  ): Record<string, unknown> {
    return {};
  },

  /**
   * @private
   */
  _readMessage: function (msg: EmptyComment, _json: any): EmptyComment {
    return msg;
  },
};

export const CommentIdJSON = {
  /**
   * Serializes CommentId to JSON.
   */
  encode: function (msg: PartialDeep<CommentId>): string {
    return JSON.stringify(CommentIdJSON._writeMessage(msg));
  },

  /**
   * Deserializes CommentId from JSON.
   */
  decode: function (json: string): CommentId {
    return CommentIdJSON._readMessage(
      CommentIdJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CommentId with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CommentId>): CommentId {
    return {
      id: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CommentId>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: CommentId, json: any): CommentId {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    return msg;
  },
};

export const UpdateCommentDtoJSON = {
  /**
   * Serializes UpdateCommentDto to JSON.
   */
  encode: function (msg: PartialDeep<UpdateCommentDto>): string {
    return JSON.stringify(UpdateCommentDtoJSON._writeMessage(msg));
  },

  /**
   * Deserializes UpdateCommentDto from JSON.
   */
  decode: function (json: string): UpdateCommentDto {
    return UpdateCommentDtoJSON._readMessage(
      UpdateCommentDtoJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes UpdateCommentDto with all fields set to their default value.
   */
  initialize: function (msg?: Partial<UpdateCommentDto>): UpdateCommentDto {
    return {
      id: 0,
      authorId: 0,
      message: "",
      attachment: "",
      postId: 0,
      createdAt: protoscript.TimestampJSON.initialize(),
      updatedAt: protoscript.TimestampJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<UpdateCommentDto>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.authorId) {
      json["authorId"] = msg.authorId;
    }
    if (msg.message) {
      json["message"] = msg.message;
    }
    if (msg.attachment) {
      json["attachment"] = msg.attachment;
    }
    if (msg.postId) {
      json["postId"] = msg.postId;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.updatedAt && msg.updatedAt.seconds && msg.updatedAt.nanos) {
      json["updatedAt"] = protoscript.serializeTimestamp(msg.updatedAt);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: UpdateCommentDto, json: any): UpdateCommentDto {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _authorId_ = json["authorId"];
    if (_authorId_) {
      msg.authorId = protoscript.parseNumber(_authorId_);
    }
    const _message_ = json["message"];
    if (_message_) {
      msg.message = _message_;
    }
    const _attachment_ = json["attachment"];
    if (_attachment_) {
      msg.attachment = _attachment_;
    }
    const _postId_ = json["postId"];
    if (_postId_) {
      msg.postId = protoscript.parseNumber(_postId_);
    }
    const _createdAt_ = json["createdAt"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _updatedAt_ = json["updatedAt"];
    if (_updatedAt_) {
      msg.updatedAt = protoscript.parseTimestamp(_updatedAt_);
    }
    return msg;
  },
};

export const CreateCommentDtoJSON = {
  /**
   * Serializes CreateCommentDto to JSON.
   */
  encode: function (msg: PartialDeep<CreateCommentDto>): string {
    return JSON.stringify(CreateCommentDtoJSON._writeMessage(msg));
  },

  /**
   * Deserializes CreateCommentDto from JSON.
   */
  decode: function (json: string): CreateCommentDto {
    return CreateCommentDtoJSON._readMessage(
      CreateCommentDtoJSON.initialize(),
      JSON.parse(json),
    );
  },

  /**
   * Initializes CreateCommentDto with all fields set to their default value.
   */
  initialize: function (msg?: Partial<CreateCommentDto>): CreateCommentDto {
    return {
      authorId: 0,
      message: "",
      attachment: "",
      postId: 0,
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: PartialDeep<CreateCommentDto>,
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.authorId) {
      json["authorId"] = msg.authorId;
    }
    if (msg.message) {
      json["message"] = msg.message;
    }
    if (msg.attachment) {
      json["attachment"] = msg.attachment;
    }
    if (msg.postId) {
      json["postId"] = msg.postId;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: CreateCommentDto, json: any): CreateCommentDto {
    const _authorId_ = json["authorId"];
    if (_authorId_) {
      msg.authorId = protoscript.parseNumber(_authorId_);
    }
    const _message_ = json["message"];
    if (_message_) {
      msg.message = _message_;
    }
    const _attachment_ = json["attachment"];
    if (_attachment_) {
      msg.attachment = _attachment_;
    }
    const _postId_ = json["postId"];
    if (_postId_) {
      msg.postId = protoscript.parseNumber(_postId_);
    }
    return msg;
  },
};

export const CommentJSON = {
  /**
   * Serializes Comment to JSON.
   */
  encode: function (msg: PartialDeep<Comment>): string {
    return JSON.stringify(CommentJSON._writeMessage(msg));
  },

  /**
   * Deserializes Comment from JSON.
   */
  decode: function (json: string): Comment {
    return CommentJSON._readMessage(CommentJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Comment with all fields set to their default value.
   */
  initialize: function (msg?: Partial<Comment>): Comment {
    return {
      id: 0,
      authorId: 0,
      message: "",
      attachment: "",
      postId: 0,
      createdAt: protoscript.TimestampJSON.initialize(),
      updatedAt: protoscript.TimestampJSON.initialize(),
      ...msg,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: PartialDeep<Comment>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.id) {
      json["id"] = msg.id;
    }
    if (msg.authorId) {
      json["authorId"] = msg.authorId;
    }
    if (msg.message) {
      json["message"] = msg.message;
    }
    if (msg.attachment) {
      json["attachment"] = msg.attachment;
    }
    if (msg.postId) {
      json["postId"] = msg.postId;
    }
    if (msg.createdAt && msg.createdAt.seconds && msg.createdAt.nanos) {
      json["createdAt"] = protoscript.serializeTimestamp(msg.createdAt);
    }
    if (msg.updatedAt && msg.updatedAt.seconds && msg.updatedAt.nanos) {
      json["updatedAt"] = protoscript.serializeTimestamp(msg.updatedAt);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Comment, json: any): Comment {
    const _id_ = json["id"];
    if (_id_) {
      msg.id = protoscript.parseNumber(_id_);
    }
    const _authorId_ = json["authorId"];
    if (_authorId_) {
      msg.authorId = protoscript.parseNumber(_authorId_);
    }
    const _message_ = json["message"];
    if (_message_) {
      msg.message = _message_;
    }
    const _attachment_ = json["attachment"];
    if (_attachment_) {
      msg.attachment = _attachment_;
    }
    const _postId_ = json["postId"];
    if (_postId_) {
      msg.postId = protoscript.parseNumber(_postId_);
    }
    const _createdAt_ = json["createdAt"];
    if (_createdAt_) {
      msg.createdAt = protoscript.parseTimestamp(_createdAt_);
    }
    const _updatedAt_ = json["updatedAt"];
    if (_updatedAt_) {
      msg.updatedAt = protoscript.parseTimestamp(_updatedAt_);
    }
    return msg;
  },
};
